{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Remote Instrumentation Interactive Guide","text":"<p>Welcome to the remote instrumentation interactive guide! This guide serves as a collection of resources, notes, and examples to help you learn about remote instrumentation with a focus on the QCoDeS python library. This guide is primarily intended for people who are just getting started with the subject.</p> <p>Feel free to update and contribute to the guide by adding your own notes, links, and/or example scripts. The QCoDeS library, in particular, is undergoing rapid development so some scripts may be outdated by the time of reading. See CONTRIBUTING for more info.</p>"},{"location":"#how-to-use","title":"How to use","text":"<p>Browse at your own leisure. The sections are organized so that they build off each other but you can search for specific information using the search bar.</p> <p>The guide will often link to example scripts which are housed in the github source repository. To run these scripts on your own device, you will need both the relevant physical instruments and software drivers. All scripts will require a working VISA installation which the guide discusses in the Intro. Other dependencies such as pyvisa, qcodes, and additional drivers will be specified in the scripts themselves and in the corresponding sections of the docs.  Some examples may not be discussed in the guide, so be sure to check out the repo itself. </p>"},{"location":"15.5_mins_to_qcodes/","title":"15 and a 1/2 mins to QCoDeS","text":"<p>Follow along with QC-Docs/15mintoQC and the example below. Note that the initialization of the mock instruments in the documentation differs from physical instruments. </p>"},{"location":"15.5_mins_to_qcodes/#object-hierarchy","title":"Object Hierarchy","text":"<p>We discuss 4 of the 5 objects listed in QC-Docs/CommunityGuide/ObjectHierarchy (sweepValues aren't essential) </p> <p>The class heirarchy goes as </p> \\[ \\textrm{Station} &gt; \\textrm{Instrument} &gt; \\textrm{Parameter} &gt; \\textrm{Validator} \\]"},{"location":"15.5_mins_to_qcodes/#instrument","title":"Instrument","text":"<p>The Instrument base class is used to define an abstraction of (in most cases) a real world instrument. QCoDeS drivers are implementations of these Instrument objects. </p> <p>Initialization: <code>DriverClass(name, address, **kwargs)</code></p> <p>where address is a VISA Resource name, such as GPIB0::5::INSTR, as in pyvisa and kwargs are any additional required key word arguments. </p> <p>A connection message of the form </p> \\[  \\textrm{Connected to: \\{instruent name\\} \\{model\\} (serial:\\{\\}, firmware:\\{\\}) in 0.03s} \\] <p>is printed with successful connection. Under the hood, this connection message is just a re-formatted version of the output from an <code>*IDN?</code> query. If your instrument doesn't comply to a standard id string format, you have to override the <code>get_idn()</code> method in your driver. See Writing Drivers</p>"},{"location":"15.5_mins_to_qcodes/#parameters","title":"Parameters","text":"<p>The Parameter class represents some 'aspect' of an instrument. They are typically defined in the driver class for the instrument, . The flexibility in the class allows it to encapsulate </p> <ul> <li>Output modes (on/off) and instrument settings (attenuation levels, time constants, ...)</li> <li>Measurable quantities: voltages, currents, resistances, ... </li> </ul> <p>The QCoDeS implementation allows parameters to be set and get in similar ways. To set a parameter value, we use <code>param(value)</code> and to get,<code>param()</code></p> <p>If defined in an instrument, you would have to expose it first, i.e <code>inst.param(value)</code>. </p> <p>Behind the scenes, the qcodes instrument driver is just packaging the user's commands into the format required by the instrument. For SCPI based devices, setting corresponds to a write command and getting to a query. But, as with pyvisa, non SCPI instruments can naturally be supported.</p>"},{"location":"15.5_mins_to_qcodes/#station","title":"Station","text":"<p>Instruments and parameters can be grouped together to form a Station.  - Initialized via <code>station = qcodes.Station()</code> - Instruments added through <code>station.add_component(inst)</code>. On addition, the station checks if all the parameters in the instrument can be set/get. Helpful for testing when building drivers yourself - Parameters via <code>station.add_component(param)</code></p>"},{"location":"15.5_mins_to_qcodes/#validator","title":"Validator","text":"<p>Validators define the constraints on parameters. They are most relevant when writing your own drivers. For example, a paramter representing the output state of a device is limited to 2 values (on/off). A `mode' parameter on a signal sourcing instrument could take on values such as ac_voltage, dc_voltage, ac_current, resistance, etc.  </p>"},{"location":"15.5_mins_to_qcodes/#useful-methods","title":"Useful Methods","text":"InstrumentParameterStation <ul> <li><code>print_readable_snapshot()</code>  gives overview of instrument status</li> <li><code>parameters()</code> lists all available parameters on instrument</li> <li><code>snapshot()</code></li> </ul> <ul> <li><code>add_validator()</code> to update and modify valid param values during experiment</li> <li><code>snapshot()</code></li> </ul> <ul> <li><code>snapshot()</code></li> </ul>"},{"location":"15.5_mins_to_qcodes/#where-to-find-drivers","title":"Where to find Drivers?","text":"<p>Qcodes provides drivers for various instruments in their <code>qcodes.instrument_drivers</code> module. Drivers are grouped by their vendor and model. For example, qcodes provides a YokogawaGS200 driver located in the <code>qcodes.instrument_drivers.yokogawa</code> module. Thus, we get access to the driver via the import <code>from qcodes.instrument_drivers.yokogawa import YokogawaGS200</code>.  Visit the Drivers examples page in the qcodes documentation to see how real instruments are initialized. </p> <p>If you can't find a driver for your instrument, you have a few options</p> <ol> <li>QCoDeS Contrib Drivers: Collection of community sourced drivers. If you end up writing a driver yourself, consider contributing it here for feedback if nothing else. </li> <li>QCoDeS forks: In the qcodes github, there are, as of writing, 300 some forks of the repository. Some may include drivers for your instrument </li> <li>Write it yourself: see Writing Drivers for more info</li> </ol>"},{"location":"15.5_mins_to_qcodes/#high-level-script-strucure","title":"High Level Script Strucure","text":"<p>The general structure of a qcodes program/notebook is</p> <ol> <li>Start logging (most useful in IPython environment)</li> <li>Instantiate the instrument drivers (and external parameters if applicable) in your experiment. Configure their settings for desired functionality.  </li> <li>Instantiate qcodes station and add components such as relevant instruments and/or individual parameters</li> <li>Setup QCoDeS Databse to store runs </li> <li>Iniitalize Experiment object (distinguishes data from other experiments in database)</li> <li>Perform measurement using measurement context or doNd module</li> <li>Teardown</li> </ol> <p>Warning</p> <p>You should refer to your instrument manual to configure settings properly using its driver. </p> <p>Examples 1. qc_sweep.py: A channel on a YokogawaGS820 linearly sweeps across voltage while a Keithley6500 measres. </p>"},{"location":"database/","title":"Database","text":"<p>The <code>initialise_or_create_database_at(path: str)</code> function commands the creation of an SQLite3 Databse in the specified path. Any method for databse access supported by SQLlite3 can then be applied to your work. </p> <p>See database_access.py for python interfacing with db. There are also a multitude of software that can visualize SQLlite3 databases, such as the SQLite Database viewer</p> <p>As far as I've seen, it's cumbersome to access database elements outside of the program. Thus, make your best efforts to save and export the relevant data for your experiments during execution. </p> <p>For measurement contexts, there are datasaver objects that give immediate access to the running data, while dond returns the output data when called. </p> <p>See transconductance.py to see results from data taken in a qcodes sweep accessed after execution. </p>"},{"location":"intro/","title":"Intro","text":"<p>Experiments require instruments. Instruments have knobs. (Ethical) labor is expensive \\(\\implies\\) Remote instrument control. In the past, instrument manufacturers provided gateways for device programming, but independently of other manufacturers. As a consequence, we're left with a clutter of different protocols, interfaces, and buses (GPIB, RS232, USB, Ethernet). </p>"},{"location":"intro/#visa","title":"VISA","text":"<p>In the (19)90s, to combat this problem, several instrument manufacturing powerhouses agreed to develop a standard for device communication. The Virtual Instruments Software Architecture (VISA) was the culmination of those efforts, providing an Application Programming Interface (API) for instrument control over the various bus systems available.</p> <p>There are several implementations of VISA. National Instruments VISA (NI-VISA) is the most common and well-supported, but there may be instances where another implementation is required. The image below outlines the software heirarchy of an instrument control scheme from the bus drivers to the high-level application. Note where NI-VISA sits.   </p> Control Layers for the NI-VISA system     <sup> 1 </sup> <p>Importantly, on top of the NI-VISA download, you'll also need the NI-Drivers for certain buses like GPIB, RS and VXI. For USB and Ethernet connections, NI-VISA has in-built support. </p>"},{"location":"intro/#scpi","title":"SCPI","text":"<p>The Standard Communications Protocol for Instruments (SCPI, pronounced 'skippy' like the 8th dwarf) was another product of standardization. It defines a format for the communication comands to be sent and received by an instrument<sup>3</sup>. A SCPI string consists of repeated command blocks that take the form </p> \\[ \\textrm{\\small cmd}\\overbrace{:\\textrm{\\small subcmd}}^{*}\\textrm{\\small{[?]}} \\quad [\\textrm{\\small param }\\underbrace{\\textrm{,param}}_{*}] \\] <p>The \\(*\\) indicates that the specified string can be repeated indefinitely and strings within square brackets [ ] are optional. Commands are scoped by colons \\(:\\) which are followed by a comma separated string of parameters which may or may not be required depending on the specific command. Multiple SCPI command blocks are separated by semicolons. Commands are either 'queries' (indicated by the question mark) or 'writes'. See the figure below for a sample of the YokogawaGS820 command tree </p> Sample from YokogawaGS820 Command Tree     <sup> 2 </sup>"},{"location":"intro/#pyvisa","title":"pyvisa","text":"<p>pyvisa can serve as both a high-level wrapper for an existing VISA installation and an implementation of VISA itself. In the first case, pyvisa calls functions in a VISA backend to manage instrument communication, whereas, in the latter, the bus protocols are directly managed in python through other libraries. </p> <p>Examples </p> <ol> <li>PHY405 initialization script Initalization of multiple instruments </li> <li> <p>yoko+kiethley_sweep Linear voltage sweep with YokogawaGS820 channel as source and KeithleyDMM6500 as measurement probe</p> </li> </ol> <p>For simple configurations, pyvisa is a convenient option, and moreover, serves as foundation for qcodes. Take time to understand how to use it. </p>"},{"location":"intro/#resources","title":"Resources","text":"<ol> <li>Youtube tutorial: Overview of pyvisa and SCPI with example code</li> <li>Blog Post by lui_gough: Introduces SCPI automation and highlights various pitfalls. Discusses bus systems and synchronization techniques</li> <li>RhodeSchwartz Remote Instrumentation Guide: Comprehensive look at remote instrumentation. Links to some proprietary RhodeSchwarz software not compatible with other instruments</li> </ol>"},{"location":"intro/#configuring-bus-sytems","title":"Configuring Bus sytems","text":"<p>Remote Instrumentation can only be so remote, you still have to get in touch with the instruments themselves. Here are some tips for configuring certain bus systems</p>"},{"location":"intro/#gpib","title":"GPIB","text":"<p>Since most modern PC's don't support GPIB natively, you will likely need a GPIB-USB adaptor. You can then connect multiple instruments over GPIB by 'daisy-chaining' the cables as long as the GPIB-USB adaptor is connected to one junction of the chain. </p> <p>It is also necessary to configure the GPIB addresses of each instrument to be distinct from one another. This requires familiarizing yourself with the manual interface for your instrument.</p> <p>If you are using the NI-VISA installation, you also need the NI-488.2 GPIB driver so that your installation can communicate over GPIB. For other VISA installations, check their instructions. TODO you do it. </p>"},{"location":"intro/#usb","title":"USB","text":"<p>Largely just plug and play, no additional NI driver needed. </p>"},{"location":"intro/#rs-232","title":"RS-232","text":"<p>This is a fairly outdated protocol. If you do have to use it, remember to install the NI-Serial driver.</p>"},{"location":"intro/#ethernet","title":"Ethernet","text":"<p>When statically configuring your device's ethernet settings, take the following steps </p> <ol> <li>Disable DHCP: Most of the time, you won't be able to tinker any ethernet settings unless this is disabled. </li> <li> <p>Determine IP address and subnet mask of ethernet adaptor: Open the command line and run </p> WindowsLinux/Mac <pre><code>ipconfig /all\n</code></pre> <pre><code>ifconfig # on mac can view system ethernet settings\n</code></pre> <p>Find the IP address and subnet mask associated with your ethernet adapter. If you have multiple ethernet ports on your pc, make sure you find the right one. </p> <p> Example <code>ipconfig /all</code> output on windows machine   IP addresses and subnet masks are 32 bit numbers expressed as period separated groups of 4 bytes represented in decimal. Thus, each group is represented by a number from 0 to \\(255 = 2^8 - 1\\). Hence, in the above example, our subnet mask in binary is \\(1^{16}0^{16}\\), by which we mean 16 1s followed by 16 0s. </p> <p>The ethernet protocol will perform a bitwise-and operation on the subnet mask and the destination ip address to help determine where to route packets.</p> </li> <li> <p>Configure Instrument Follow the instructions in your instrument's manual to set your instruments subnet mask to match the pc's. Then choose an IP address (not equal to the pc's) which matches the pc's wherever the subnet mask has a bit 1. In the above example, we are free to set the device's IP address to anything of the form <code>169.254.xxx.xxx</code> since the subnet is 1 in the first 16 bits and 0 in the last. </p> </li> <li> <p>Test Ethernet Connection Open a terminal/command prompt on your pc and ping the device. If we set a device to ip address <code>169.254.169.1</code>, then execute <code>ping 169.254.169.1</code>. If the ping fails, redo the last steps. If it still fails, then check your instrument manual to see if there are further requirements on the ethernet cable standard that should be used.       Example successful ping output </p> </li> <li> <p>Test Visa Connection Open NI-MAX (should come with your NI-VISA installation).     <pre><code>    Devices and Interfaces &gt; Create New &gt; VISA TCP/IP Resource &gt; Auto-detect of LAN Instrument\n</code></pre> NI-MAX autodetect LAN      You should be able to find your device ip addresses here. Copy the VISA address displayed corresponding to your instrument and use your choice of pyvisa, qcodes, or even NI MAX itself to test that your device can send/receive data over ethenet.     Remark in pyvisa, remember to set your write and read termination characters. </p> </li> </ol>"},{"location":"intro/#whats-missing","title":"What's missing?","text":"<p>As your experimental setup grows, it becomes increasingly difficult to manage all the various instrument-specific command interfaces. The inclination with pyvisa is to write drivers for yourself to abstract away the lower level SCPI commands.  </p>"},{"location":"intro/#qcodes-shows-up","title":"QCoDeS shows up","text":"<p>Another layer of abstraction higher than pyvisa with many more features. Aims to quench the desire for instrument modules that you'd likely end up developing yourself (see Examples 2) The library provides drivers for a number of common instruments and is robustly featured in hopes of delivering all the software required for large-scale experimental setups. </p> <p>Installation Follow the Getting Started section of the qcodes docs. Use the recommended approach with miniconda, but make sure to use the latest version of python you installed when setting up the conda environment. The latest qcodes version requires python 3.11 and up as opposed to 3.9 as currently specified in the docs. If nothing else, run <code>pip install qcodes</code> (like I did). The issue here is that as qcodes develops, there may be some compatibility problems in the future.  </p> <ol> <li> <p>greetings\u00a0\u21a9</p> </li> <li> <p>YokogawaGS820 Documentation \u21a9</p> </li> <li> <p>Many instruments have support for several command protocols so you may have to configure your instrument for SCPI. We discuss SCPI here since it's so ubiquitous, but you can use the command scheme of your choice.\u00a0\u21a9</p> </li> </ol>"},{"location":"issues/","title":"Issues","text":""},{"location":"issues/#serial-port-initialization","title":"Serial port initialization","text":"<p>When Arduino connects to computer, it resets. It then takes time for the arduino to setup serial communication (has to run the bootloader, gets to Serial.begin() in 2 seconds or so). Currently, in pyvisa the instrument is available for use after opening a resource. If no wait time is applied between opening arduino-based instrument, then pyvisa can throw error as it tries to read/write to uninitialized serial buffer.  See      - Disable Arduino's Auto-Reset on Connection     - Serial Input Basics</p> <p>RESOLVED override the <code>get_idn()</code> method and sleep for 3 seconds before continuing. That way, when <code>self.connect_message</code> is called after initialization, the serial port will be up and running. Hardware corrections will make reprogramming the arduino more difficult. Add 3 second sleep to init function in driver before <code>self.connect_message()</code> is called. You may still have to override <code>get_idn()</code> if your instrument doesn't return a standard identification string. See one of the sections above TODO which section?  </p>"},{"location":"issues/#synchronization","title":"Synchronization","text":"<p>Related to above issue. How to ensure synchronization of commands? Develop some implementation of  <code>*OPC</code> and/or <code>*WAI</code> commands.</p>"},{"location":"issues/#ipython-compatibility","title":"IPython Compatibility","text":"<p>QCoDeS designed to run in ipython environments (jupyter notebooks). Interactive widgets, in line plotting, and logging are only available in ipython. </p>"},{"location":"issues/#no-output-parameter","title":"No output Parameter","text":"<p>The QCoDeS documentation recommends assigning parameters defined via <code>self.add_parameter(...)</code> to similarly named attributes for compatibility with code editor's auto-completion systems. The problem is 2-fold      1. If assigned as <code>self.param = self.add_parameter(...)</code>, then for some reason, qcodes throws an error when you try to set/get self.param as you would a regular parameter. i.e, if in some driver method, you want to set param, <code>self.param(x)</code> throws an error. In fact, digging into the source code for the InstrumentBase class reveals that the <code>add_parameter()</code> method returns Nonetype! If no assignment is made to a class attribute, then this problem disappears.      2. To resolve the above issue, I directly instantiated parameters from the Parameter class and assigned to a class attribute as recommended. <code>self.param = Parameter(self.inst, ...)</code> (note that a reference to the instrument itself has to be passed here). This enabled the usual syntax for setting/getting the param, but vscode still didn't recognize any of the attributes/methods of the driver class. This was observed in the YokogawaGS820 driver, which is likely a consequence of relegating parameter constructions to the InstrumentChannel class. </p> <p>RESOLVED:  A number of their instruments have been modified to conform to method 2. To see this discrepancy firsthand, take a look at the Weinschel8320 driver in QC-Docs/CreatingInstrumentDrivers. Notice that they use method 1 here. But, if you look at the source code for the driver here, you'll notice that method 2 was snuck in. I was using qcodes version 0.45.0 which had <code>self.add_parameter</code> return NoneType. In version 0.46.0 and above, the method returns the parameter allowing approach 1 above to work. </p>"},{"location":"logging/","title":"Logging","text":"<p>Doesn't work as intended outside of IPython, see Issue 3. Offloads to standard logger python library. Read documentation there to understand. Still, implement logging when creating drivers. To enable logging, put  <pre><code>from qcodes.logger import start_all_logging\nstart_all_logging()\n</code></pre> at top of your programming. Log files are stored in the <code>/.qcodes/logs</code> folder in your home directory. You can export them to pandas df for better viewing via </p> <p>TODO Show how to view</p>"},{"location":"measurements/","title":"Taking Measurements","text":""},{"location":"measurements/#using-a-measurement-context","title":"Using a Measurement Context","text":"<p>Follow The Measurement Context Manager section of QC-Docs/15mintoQC.  Note that Measurement Contexts are initialized with a Station and Experiment. The context relies on the snapshot method from the station. </p> <p>User defines the dependent and independent parameters under study. </p> <p>See QC-Docs/Dataset/MeasuringX(t) for measurements of time parameters</p>"},{"location":"measurements/#using-dond","title":"Using doNd","text":"<p>Measurement contexts allow for complete freedom in experiment design, however, for standard measurements such as linear sweeps, they are over exposed pieces of software. QCoDeS provide highly optimized data handling for such measurements.  QC-Docs/DataSet/UsingDoND... explores the capabilities of the module, which include  - Support for multi channel sweeps over multiple independent parameters. Linear and logarithmic sweeps built-in - Simultaneous 'Together plotting'. View at qc_doNd_together_sweep.py - \\(n\\) dimensional sweeps by feeding sweeps into each other</p> <p>Calling the <code>doNd()</code> returns a tuple of objects. The first of which can be plotted via the plot function from <code>qcodes.utils.dataset.doNd</code>.  If you are in an IPython environment, you can configure the doNd for auto plotting. Outside, the best choice is plottr.</p> <p>Note</p> <p>plottr doesn't have integrated support for general \\(n\\) dimensional plotting. See this resource for more info </p> <p>Examples 1. qc_doNd_together_sweep.py Both output channels of YokogawaGS820 linearly sweep over voltage while Keithley2400 and Keithley6500 take measurements. Plotted data shows recorded voltages over the linearly sweeped parameter space resulting in heatmap over diagonal with x and y axes being yoko voltages. Compare with qc_sweep.py to appreciate the power of doNd. The Keithly2400 driver is provided by qcodes core driver library, but the script Requires      1. in-house YokogawaGs820 driver      2. modified Keithley6500 driver.  </p>"},{"location":"measurements/#saving-data-in-memory","title":"Saving Data in Memory","text":"<p>Can save data in memory instead of to SQLite3 database to save time. But, no protection against memory loss. If computer crashes during experiment, data is vanquished. TODO: Look at Saving DataInMem,  OptimizingDataTime, SavingDataInBG</p>"},{"location":"virtual_parameters/","title":"Virtual Parameters","text":"<p>QCoDeS supports the abstraction of existing parameters/instruments in a variety of ways.</p>"},{"location":"virtual_parameters/#delegate-parameter","title":"Delegate Parameter","text":"<p>Parameters whose setting/getting is offloaded to other underlying parameters in an instrument. Can be used to represent inferrable quantities that require conversion from other parameters. </p> <p>Also helpful for writing drivers. See implementation of source setting in Custom YokogawaGS820 Driver</p>"},{"location":"virtual_parameters/#parameters-with-setpoints","title":"Parameters with Setpoints","text":"<p>Useful for defining parameters based on arrays of existing values. See [QC-Docs/Params_with_setpoints](http://</p> <p>microsoft.github.io/Qcodes/examples/Parameters/Simple-Example-of-ParameterWithSetpoints.html) and then QC-Docs/Params_setpoints_on_other_instruments</p>"},{"location":"virtual_parameters/#delegate-instruments","title":"Delegate Instruments","text":"<p>To create containers for parameters in different instruments. Most easily achieved via YAML configuration See QC-Docs/YAML-Deleg for introductory information and QC-Docs/YAML-InstrumentGroup to see how this can approach can be used to model devices on a chip</p>"},{"location":"writing_drivers/","title":"Writing Drivers","text":"<p>Creating drivers amounts to defining a subclass of some base Instrument class and writing out the declarations for the parameters you want to include. It is recommended that you inherit from the VisaInstrument base class as it allows you to create a simulated instrument for your driver to test trivial functionality.  </p>"},{"location":"writing_drivers/#template","title":"Template","text":"<p>Info</p> <p>The following template requires that you have qcodes 0.46.0 and up. With previous versions, <code>self.add_parameter()</code> did not return anything, leading to Issues</p> Instrument Driver template<pre><code>from qcodes.instrument import VisaInstrument\n\n# If you are using method 2 for adding parameters\nfrom qcodes.Parameter import Parameter\n\n# log messages outside of instrument \nlog = logging.getLogger(__name__)\n\n# Inherit From VisaInstrument class\nclass YourInstrument(VisaInstrument):\n    def __init__(self, name:str, address:str, terminator:str = '\\n', **kwargs: Any) -&gt; None:\n        # Setup connection and other higher level items with parent Constructor\n        super().__init__(name, address, terminator, **kwargs)\n\n        # Add parameters here. You can define helper methods in the class\n        # for the get_cmds and set_cmds. Here's an example\n        # *Important*: assign the new parameter to a class attribute \n        # to meet modern qcodes standard (helps intellisense in code editors) \n\n        # Here is the method I recommend you use to add parameters \n        self.current = self.add_parameter(\n            name = \"current\",\n            label=\"Current\",\n            # output of asks is a string, this ensures conversion to float\n            # note, you can set this to a function if you want more \n            # complicated behaviour\n            get_parser=float,\n            get_cmd=...,\n            set_cmd=...,\n            vals=...)\n        \"Docstring for current here\"\n\n\n        # Not recommended since instrument=self is easy to forget\n        self.voltage = Parameter(\n            \"voltage\",\n            label=\"Voltage\",\n            get_parser=float,\n            get_cmd=...,\n            set_cmd=...,\n            vals=...,\n            # requires this line\n            instrument=self\n        )\n        \"Docstring for voltage parameter here\"\n\n\n        # At the end of the init function, make this method call defined \n        # in the Instrument class to print a connection msg\n        # IMPORTANT: your instrument must return a standard id string on \n        # a *IDN? query for this method to work. Else, override the get_idn()\n        # method. See remarks below\n        self.connect_message() \n</code></pre> <p>Arguments to <code>self.add_parameter(...)</code> 1. name: TODO: look into  2. label: TODO: what diff 3. get_parser (optional): on queries, the driver receives data from the instrument in the form of a string. Specifying a get_parser allows you to update/modify the string data. If set to a primitive data type like <code>int</code> or <code>float</code>, then conversion is made implicitly. You can alternatively pass in a custom function </p> <p>How do you query and write to the instrument when inside a driver? You can use these inherited methods defined in InstrumentBase 1. Query: <code>self.ask(cmd: str)</code> 2. Write: <code>self.write(cmd: str)</code> You'll see these methods used often in the drivers you'll encounter. It may even be necessary to override them in some cases. See Keithley_2600 Driver. Also note that this instrument doesn't communicate using SCPI, but instead the TSP protocol. </p> <p>If you want to include a parameter that is only settable/gettable, assign the set_cmd/get_cmd to False, not None. None corresponds to a manual parameter. </p> <p>Note that when you inherit from the VisaInstrument class, you'll see that the class heirarchy goes as  </p> \\[ \\underbrace{\\textrm{VisaInstrument}}_{\\textrm{Sets up VISA  connection}} \\longrightarrow \\overbrace{\\textrm{Instrument}}^{\\textrm{adds IDN param and some methods}} \\longrightarrow \\underbrace{\\textrm{InstrumentBase}}_{\\textrm{defines add\\_parameter, etc}} \\] <p>where \\(a \\to b\\) signifies that \\(a\\) is a child of \\(b\\).  Exercises It's instructive to peek through the curtains of the qcodes api and see how these lines of codes actually control the instrument. Try out the following exercises. </p> <ol> <li>With the hierarchy above in miind, probe the source code for this Weinschel Instrument Driver to investigate the following questions. Note: you can either search for the class source code at the given link, or if you have qcodes installed, you can use your code editor to look into the source files with the help  of code navigation. When inheriting from the VisaInstrument class, <ol> <li>How is the visa address and backend specified for the instrument and where is the connection initialized?</li> <li>What instrument parameter is added first?</li> </ol> </li> <li>If no additional parameters/functions are defined in an instrument that inherits from VisaInstrument, which of the following methods/parameters will be available?     a. <code>self.close()</code>     b. <code>self.reset()</code>      c. <code>self.connect_message()</code>     d. <code>self.model</code></li> </ol> <p>Solutions</p> Look at to verify  1. I explored source on vscode editor      1. VisaInstrument class **TODO** add solution      2. the IDN parameter 2. (b) and (d) are NOT defined. close and connect methods are inherited from InstrumentBase  <p>Examples 1. Custom YokogawaGS820 Driver: Molded from the YokogawaGS200 driver and components from several others with modernized code. Supports only sourcing capabilities of the yoko currently (no measurements possible). Each channel treated as an instrument itself. Variations in range settings for different models handled in base class.  2. Modified Keithley6500 Driver: Modified from core Keithely6500 driver to include input_impedance parameter and continuous reading mode (not succesful). Required updating setter functions. 3. AC Box Driver: Driver for Barrera Lab's custom built AC-DAC AD9106 Waveform generator TODO Update link when file name changes 4. DC Box Driver: Driver for Barrera Lab's custom built DC-DAC AD5764 DC generator </p> <p>Warning</p> <p>If you don't override the <code>get_idn()</code> method, then you have to ensure that your instrument supports the <code>*IDN?</code> SCPI query, and moreover, returns a string formatted as </p> \\[ \\textrm{\\{vendor\\}[s]\\{model\\}[s]\\{serial\\}[s]\\{firmware\\}} \\] <p>where \\([s]\\) denotes a separator which is either a comma, colon, or semicolon. Comma is more standard. </p> <p>Info</p> <p>For Arduino controlled devices operating over the Serial bus, it should be noted that Ardunos reset themselves when opening a serial connection (a byproduct of making firmware programming accessible). The current fix is to sleep for 3 seconds in the init method of the driver before <code>self.connect_message()</code> is called. </p>"},{"location":"writing_drivers/#testing-your-driver","title":"Testing your Driver","text":"<p>If you want to make a contribution to the qcodes community driver library, you'll have to implement some of their testing protocols. </p> <p>To test trivial functionality and ensure `continuous integration', instantiate a Simulated Instrument of your driver and verify that connection is possible. This requires writing a yaml file for a pyvisa simulated instrument and then passing the file into your instrument. </p> <p>Examples 1. BarreraDCDAC5764 Simulated Instrument using DCDAC_5764.yaml</p> <p>With the physical instrument on hand, you can use standard testing frameworks such as pytest, unittest, etc to verify parameter setting/getting and instrument communication works.  Examples  1. yoko_pytest 2. BarreraDCDAC5764 unittest</p>"},{"location":"writing_drivers/#pipeline-for-custom-instruments","title":"Pipeline for Custom Instruments","text":"<ol> <li>Build Instrument with SCPI support over some bus     For Arduino-driven instruments, see TODO: add user guide.      Ensure that data is buffered out of instrument only on query commands or else you have to do a lot more post-processing on the driver end.  </li> <li>Use pyvisa to perform functional testing of remote access     Confirm connection and data transfer works as intended. Remember to account for terminator characters. </li> <li>Build qcodes driver     Inherit from VisaInstrument class if possible (allows construction of virtual instrument)      If instrument is programmed properly, the qcodes driver only needs to know the command tree and expected in/outputs. So this step could be done in parallel with construction, assuming good planning. </li> <li>Test integration with Virtual Instrument     Instantiate a virtual instrument of your driver to verify trivial functionality. </li> <li>Comprehensive Testing     Test getting/setting of all parameters. Verify that snapshots are correct at each point in time. Benchmark performance</li> </ol>"},{"location":"yaml_config/","title":"Station Configuration via YAML","text":"<p>Station initialization can be configured in a YAML configuration file. YAML is similar to JSON in that it is a human-readable data format. </p> <p>Documentation at QC-Docs/YAML</p> <p>Configures initialization of multiple instruments and parameters. Provide access by initializing station with config file, <code>station = qcodes.Station(config.yaml)</code></p> <p>Examples 1. sweep_station.yaml and qc_sweep_yaml to see how custom drivers can be initialized. Note that the sweep here uses the do1d module as opposed to the measurement context in qc_sweep</p>"}]}