# Object Hierarchy 

**TODO** include how to find resource addresses and restructure to be neater. 

We discuss 4 of the 5 objects listed in [QC-Docs/CommunityGuide/ObjectHierarchy](http://microsoft.github.io/Qcodes/community/objects.html) (sweepValues aren't essential)
```math
\textrm{Station} > \textrm{Instrument} > \textrm{Parameter} > \textrm{Validator}
```

The ***Instrument*** base class is used to define an abstraction of (in most cases) a real world instrument. QCoDeS drivers are implementations of these Instrument objects. 
- Initialization: `DriverClass(name, address)`. where address is a VISA Resource name, such as GPIB0::5::INSTR, as in pyvisa. A connection message is usually printed with successful connection. Under the hood, this connection message is just a re-formatted version of the output from an `*IDN?` query.


Useful methods
1. `IDN()` qcodes level `*IDN?` SCPI query
2. `print_readable_snapshot` as it sounds. Useful for observing the available parameters (see below) 

The ***Parameter*** class represents some `aspect' of that instrument. They are typically defined in the driver class for the instrument, but in some cases you may have to instantiate a parameter outside an Instrument. The flexibility in the class allows it to encapsulate 
- Output modes (on/off) and instrument settings (attenuation levels, time constants, ...)
- Measurable quantities: voltages, currents, resistances, ... 

The QCoDeS implementation allows parameters to be set and get in similar ways
- Setting: `param(value)`
- Getting: `param()`

If defined in an instrument, you would have to expose it first, i.e `inst.param(value)`. 

Behind the scenes, the qcodes instrument driver is just packaging the user's commands into the format required by the instrument. For SCPI based devices, setting corresponds to a write command and getting to a query. But, as with pyvisa, non SCPI instruments can naturally be supported.

***Validators*** define the constraints on parameters. They are most relevant when writing your own drivers. For example, a paramter representing the output state of a device is limited to 2 values (on/off). A `mode' parameter on a signal sourcing instrument could take on values such as ac_voltage, dc_voltage, ac_current, resistance, etc.  

Instruments and parameters can be grouped together to form a ***Station***. 
- Initialized via `station = qcodes.Station()`
- Instruments added through `station.add_component(inst)`. On addition, the station checks if all the parameters in the instrument can be set/get. Helpful for testing when building drivers yourself
- Parameters via `station.add_component(param)`

Useful methods 
1. `snapshot` provides detailed log of all station components and settings 

# 15 and a 1/2 mins to QCoDeS
Follow along with [QC-Docs/15mintoQC](http://microsoft.github.io/Qcodes/examples/15_minutes_to_QCoDeS.html) and the example below. Note that the initialization of the mock instruments in the documentation differs from physical instruments. 

## Where to find Drivers? 
Qcodes provides drivers for various instruments in their `qcodes.instrument_drivers` module. Drivers are grouped by their vendor and model. For example, qcodes provides a YokogawaGS200 driver located in the `qcodes.instrument_drivers.yokogawa` module. Thus, we get access to the driver via the import `from qcodes.instrument_drivers.yokogawa import YokogawaGS200`. 
Visit the Drivers examples page in the qcodes documentation to see how real instruments are initialized. 

If you can't find a driver for your instrument, you have a few options
1. [QCoDeS Contrib Drivers](https://github.com/QCoDeS/Qcodes_contrib_drivers): Collection of community sourced drivers. If you end up writing a driver yourself, consider contributing it here for feedback if nothing else. To use, you need to `pip install qcodes-contrib-drivers`
2. QCoDeS forks: In the qcodes github, there are, as of writing, 300 some forks of the repository. Some may include drivers for your instrument 
3. Write it yourself: see [Writing Drivers](#writing-drivers) for more info

## High Level Script Strucure
The general structure of a qcodes program/notebook is
1. Start logging (most useful in IPython environment)
2. Instantiate the instrument drivers (and external parameters if applicable) in your experiment. Configure their settings for desired functionality$^1$.  
3. Instantiate qcodes station and add components such as relevant instruments and/or individual parameters
4. Setup QCoDeS Databse to store runs 
5. Iniitalize Experiment object (distinguishes data from other experiments in database)
6. Perform measurement using measurement context or doNd module
7. Teardown

$^1$Note that you should refer to your instrument manual to configure settings properly using its driver. 

**Examples**
1. [qc_sweep.py](/QCoDeS/src/qcodes_testing/qc_sweep.py): A channel on a YokogawaGS820 linearly sweeps across voltage while a Keithley6500 measres. 
